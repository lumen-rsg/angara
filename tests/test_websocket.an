attach WebSocket, connect from websocket;
attach time;
attach io;
attach adv_string;

let should_exit = false;
let exit_mutex = Mutex();

// --- CHANGE 1: The sender thread will be a shared variable ---
// We declare it here so both `main` and `on_open` can access it.
let sender_thread as Thread;


// --- Sender Thread Logic (No changes needed here) ---

// This function will be executed in a separate thread.
// Its logic is already correct. It will only be *started*
// after the connection is confirmed to be open.
func message_sender(ws as WebSocket) -> any {
  io.println(1, "[SENDER] Sender thread has started.");
  let count = 0;
  while (count < 5) {
    // This check is still good practice, in case the connection
    // drops while this thread is running.
    if (!ws.is_open()) {
      io.println(1, "[SENDER] Connection is no longer open. Stopping.");
      break;
    }
    time.sleep(1.0);
    let message = "Ping #" + string(count + 1);
    io.println(1, "[SENDER] Sending: '" + message + "'");
    ws.send(message);
    count = count + 1;
  }
  if (ws.is_open()) {
    io.println(1, "[SENDER] All messages sent. Closing connection.");
    ws.close();
  }
  io.println(1, "[SENDER] Sender thread has finished.");
}


// --- WebSocket Callback Functions ---

// CHANGE 2: The `on_open` callback now has a critical new responsibility.
func on_open(ws as WebSocket) -> nil {
  io.println(1, "[CLIENT] Connection established to echo server.");

  // This is the correct moment to start the sender thread.
  // We assign the new thread to the shared variable.
  io.println(1, "[CLIENT] Spawning sender thread from on_open callback...");
  sender_thread = spawn(message_sender, ws);
}

func on_message(ws as WebSocket, message as string) -> nil {
  io.println(1, "[CLIENT] Received echo: '" + message + "'");
}

func on_close(ws as WebSocket) -> nil {
  io.println(1, "[CLIENT] Connection closed.");
  exit_mutex.lock();
  should_exit = true;
  exit_mutex.unlock();
}

func on_error(ws as WebSocket, error_message as string) -> nil {
  io.println(2, "[CLIENT] Connection error: " + error_message);
  exit_mutex.lock();
  should_exit = true;
  exit_mutex.unlock();
}


export func main() -> i64 {
  io.println(1, "--- Angara Multi-threaded WebSocket Test ---");

  const WEBSOCKET_URL = "ws://localhost:8080";
  let callbacks = {
    "on_open": on_open,
    "on_message": on_message,
    "on_close": on_close,
    "on_error": on_error
  };

  try {
    // 1. Initiate the connection. This returns immediately.
    let ws = connect(WEBSOCKET_URL, callbacks);
    io.println(1, "[MAIN] WebSocket connection initiated...");

    // CHANGE 3: The sender thread is NO LONGER spawned here.

    // 2. The main thread's event loop.
    io.println(1, "[MAIN] Entering event loop...");
    while (true) {
      exit_mutex.lock();
      let done = should_exit;
      exit_mutex.unlock();
      if (done) { break; }

      ws.service();
      time.sleep(0.01);
    }

    io.println(1, "\n[MAIN] Event loop finished. Joining sender thread...");

    // CHANGE 4: Make the join call robust.
    // It's possible the connection failed and the thread was never spawned.
    if (sender_thread != nil) {
      sender_thread.join();
    }

    io.println(1, "[MAIN] Test complete.");

  } catch (e) {
    io.println(2, "[MAIN] An unhandled exception occurred: " + string(e));
    return 1;
  }
  return 0;
}