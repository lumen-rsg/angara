attach websocket;
attach WebSocket from websocket;
attach io;

// A global variable to signal when the test is complete.
let is_done = false;

// --- WebSocket Callback Functions ---

// This will be called when the connection is successfully established.
func on_open(ws as WebSocket) -> void {
  io.println(1, "[SUCCESS] WebSocket connection established!");
  io.println(1, "Sending message: 'Hello from Angara!'");
  ws.send("Hello from Angara!");
}

// This will be called for every message received from the server.
func on_message(ws as WebSocket, message as string) -> void {
  io.println(1, "[MESSAGE] Received from server: '" + message + "'");

  // If we got our own message back, the test is successful.
  if (message == "Hello from Angara!") {
    io.println(1, "Echo successful. Closing connection...");
    ws.close();
  } else {
    io.println(1, "Error: Received unexpected message!");
    ws.close();
  }
}

// This will be called when the connection is closed, either by us or the server.
func on_close(ws as WebSocket) -> void {
  io.println(1, "[CLOSED] WebSocket connection closed.");
  is_done = true; // Signal the main loop to exit.
}

// This will be called if the connection fails to establish.
func on_error(ws as WebSocket, error_message as string) -> void {
  io.println(2, "[ERROR] WebSocket connection failed: " + error_message);
  is_done = true; // Signal the main loop to exit.
}


export func main() -> i64 {
  io.println(1, "--- Angara WebSocket Module Test ---");

  // A well-known public WebSocket echo server.
  const WEBSOCKET_URL = "wss://ws.postman-echo.com/raw";

  // The record of Angara closures that will handle events.
  let callbacks = {
    "on_open": on_open,
    "on_message": on_message,
    "on_close": on_close,
    "on_error": on_error
  };

  try {
    io.println(1, "Attempting to connect to " + WEBSOCKET_URL);
    let ws = websocket.connect(WEBSOCKET_URL, callbacks);

    // This is the event loop. We must periodically call `ws.service()`
    // to allow libwebsockets to process network events.
    while (!is_done) {
      ws.service();
      // A short sleep is good practice to prevent the loop from
      // spinning and consuming 100% CPU. A `time` module would be needed for this.
      // For now, it will spin, which is acceptable for a short test.
    }

    io.println(1, "\nEvent loop finished.");

  } catch (e) {
    io.println(2, "An unhandled exception occurred: " + string(e));
    return 1;
  }

  return 0;
}